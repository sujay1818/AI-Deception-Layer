# logger.py
# logger.py
from __future__ import annotations

import os
import uuid
from datetime import datetime, timezone
from typing import Any, Dict, Optional

from pymongo import MongoClient, errors

# Optional: keep last N events in memory (useful for debugging)
EVENT_LOGS = []
MAX_INMEM_EVENTS = 200

_client: Optional[MongoClient] = None
_db = None
_events = None
_deceptions = None
_sessions = None


def _utc_now_iso() -> str:
    return datetime.now(timezone.utc).isoformat()


def init_db() -> bool:
    """
    Initialize Cosmos(Mongo) connection once.
    Call this on app startup (or first log) safely.
    Returns True if DB is ready, else False.
    """
    global _client, _db, _events, _deceptions, _sessions

    if _client is not None:
        return True

    uri = ""
    if not uri:
        print("[logger] COSMOS_MONGO_URI not set. Logging will be in-memory only.")
        return False

    try:
        _client = MongoClient(uri, serverSelectionTimeoutMS=4000)
        # quick connectivity check
        _client.admin.command("ping")

        _db = _client["honeypot"]
        _events = _db["events"]
        _deceptions = _db["deceptions"]
        _sessions = _db["sessions"]

        # Helpful indexes (safe to call repeatedly)
        _events.create_index("timestamp")
        _events.create_index("session_id")
        _deceptions.create_index("timestamp")
        _deceptions.create_index("session_id")
        _sessions.create_index("session_id", unique=True)

        print("[logger] Connected to Cosmos DB (Mongo).")
        return True

    except Exception as e:
        print(f"[logger] DB init failed: {e}. Logging will be in-memory only.")
        _client = None
        return False


def log_event(event_dict: Dict[str, Any]) -> Dict[str, Any]:
    """
    Store an incoming request/event.
    Returns the full event object (with event_id/timestamp).
    """
    init_db()

    event = {
        "event_id": str(uuid.uuid4()),
        "timestamp": _utc_now_iso(),
        **event_dict,
    }

    # In-memory (optional)
    EVENT_LOGS.append(event)
    if len(EVENT_LOGS) > MAX_INMEM_EVENTS:
        EVENT_LOGS.pop(0)

    # DB write (best-effort)
    if _events is not None:
        try:
            _events.insert_one(event)
        except errors.PyMongoError as e:
            print(f"[logger] insert event failed: {e}")

    return event


def log_deception(deception_dict: Dict[str, Any]) -> Dict[str, Any]:
    """
    Store the deception result generated by Person 2 engine.
    """
    init_db()

    deception = {
        "deception_id": str(uuid.uuid4()),
        "timestamp": _utc_now_iso(),
        **deception_dict,
    }

    if _deceptions is not None:
        try:
            _deceptions.insert_one(deception)
        except errors.PyMongoError as e:
            print(f"[logger] insert deception failed: {e}")

    return deception


def upsert_session(session_id: str, update: Dict[str, Any]) -> None:
    """
    Keep one doc per attacker session (for dashboards).
    """
    init_db()
    if _sessions is None:
        return

    try:
        _sessions.update_one(
            {"session_id": session_id},
            {
                "$set": {**update, "last_seen": _utc_now_iso()},
                "$setOnInsert": {"session_id": session_id, "first_seen": _utc_now_iso(), "total_requests": 0},
                "$inc": {"total_requests": 1},
            },
            upsert=True,
        )
    except errors.PyMongoError as e:
        print(f"[logger] upsert session failed: {e}")
